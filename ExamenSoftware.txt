
Ingenier√≠a de software

Seg√∫n Sommerville (2005), para muchas personas el software son solo programas de computadora, sin embargo nos comenta que son todos aquellos documentos asociados a la configuraci√≥n de datos que se necesitan para hacer que estos programas operen de manera adecuada. Estos productos de software se desarrollan para alg√∫n cliente en particular o para un mercado en general. Para el dise√±o y desarrollo de proyectos de software se aplican metodolog√≠as, modelos y t√©cnicas que permiten resolver los problemas. En los a√±os 50 no exist√≠an metodolog√≠as de desarrollo, el desarrollo estaba a cargo de los propios programadores. De ah√≠ la importancia de contar con analistas y dise√±adores que permitieran un an√°lisis adecuado de las necesidades que se deber√≠an de implementar. 

Aun as√≠ los resultados eran impredecibles, no se sab√≠a la fecha exacta en que concluir√≠a un proyecto de software, no hab√≠a forma de controlar las actividades que se estaban desarrollando. Tampoco se contaba con documentaci√≥n estandarizada. El nacimiento de t√©cnicas estructuradas es lo que da origen al desarrollo de aplicaciones a trav√©s de m√©todos de ingenier√≠a. La inform√°tica aporta herramientas y procedimientos que se apoyan en la ingenier√≠a de software con el fin de mejorar la calidad de los productos de software, aumentar la productividad y trabajo de los ingenieros desarrolladores de software, facilitar el control del proceso de desarrollo de software y suministrar a los desarrolladores las bases para construir software de alta calidad en una forma eficiente, Gacit√∫a(2003). 

El objetivo principal que busca la ingenier√≠a de software es convertir el desarrollo de software en un proceso formal, con resultados predecibles, que permitan obtener un producto final de alta calidad y satisfaga las necesidades y expectativas del cliente. Seg√∫n Gacit√∫a (2003), la Ingenier√≠a de Software es un proceso intensivo de conocimiento, que abarca la captura de requerimientos, dise√±o, desarrollo, prueba, implantaci√≥n y mantenimiento. Generalmente a partir de un complejo esquema de comunicaci√≥n en el que interact√∫an usuarios y desarrolladores, el usuario brinda una concepci√≥n de la funcionalidad esperada y el desarrollador especifica esta funcionalidad a partir de esta primera concepci√≥n mediante aproximaciones sucesivas. Este ambiente de interacci√≥n motiva la b√∫squeda de estrategias robustas para garantizar que los requisitos del usuario ser√°n descubiertos con precisi√≥n y que adem√°s ser√°n expresados en una forma correcta y sin ambig√ºedad, que sea verificable, trazable y modificable. 

El t√©rmino ingenier√≠a del software empez√≥ a usarse a finales de la d√©cada de los sesenta, para expresar el √°rea de conocimiento que se estaba desarrollando en torno a las problem√°ticas que ofrec√≠a el software. En esa √©poca, el crecimiento espectacular de la demanda de sistemas de computaci√≥n cada vez m√°s y m√°s complejos, asociado a la inmadurez del propio sector inform√°tico (totalmente ligado al electr√≥nico) y a la falta de m√©todos y recursos, provoc√≥ lo que se llam√≥ la crisis del software. Durante esa √©poca muchos proyectos importantes superaban con creces los presupuestos y fechas estimados. La crisis del software finaliz√≥ pues se comenz√≥ a progresar en los procesos de dise√±o y metodolog√≠as. 

Seg√∫n Silva (2001) desde 1985 hasta el presente, han ido apareciendo herramientas, metodolog√≠as y tecnolog√≠as que se presentaban como la soluci√≥n definitiva al problema de la planificaci√≥n, previsi√≥n de costos y aseguramiento de la calidad en el desarrollo de software. La dificultad propia de los nuevos sistemas, y su impacto en las organizaciones, ponen de manifiesto las ventajas, y en muchos casos la necesidad, de aplicar una metodolog√≠a formal para llevar a cabo los proyectos de este tipo. La ingenier√≠a de software es una tecnolog√≠a multicapa en la que, seg√∫n Pressman (2005), se pueden identificar: los m√©todos, el proceso (que es el fundamento de la Ingenier√≠a de Software, es la uni√≥n que mantiene juntas las capas de la tecnolog√≠a) y las herramientas (soporte autom√°tico o semiautom√°tico para el proceso y los m√©todos). Como disciplina, establece el proceso de definici√≥n de requerimientos en una sucesi√≥n de actividades mediante las cuales lo que debe hacerse, se modela y analiza (Choque, 2001). 

Una parte importante de la ingenier√≠a de software es el desarrollo de metodolog√≠as y modelos. En la actualidad ha habido muchos esfuerzos que se han encaminado al estudio de los m√©todos y t√©cnicas para lograr una aplicaci√≥n m√°s eficiente de las metodolog√≠as y lograr sistemas m√°s eficientes y de mayor calidad con la documentaci√≥n necesaria en perfecto orden y en el tiempo requerido. Gacit√∫a (2003), plantea que una metodolog√≠a impone un proceso de forma disciplinada sobre el desarrollo de software con el objetivo de hacerlo m√°s predecible y eficiente. Una metodolog√≠a define una representaci√≥n que permite facilitar la manipulaci√≥n de modelos, y la comunicaci√≥n e intercambio de informaci√≥n entre todas las partes involucradas en la construcci√≥n de un sistema. 

Goncalves (2005) plantea que la experiencia ha demostrado que los proyectos exitosos son aquellos que son administrados siguiendo una serie de procesos que permiten organizar y luego controlar el proyecto, considerando v√°lido destacar que aquellos procesos que no sigan estos lineamientos corren un alto riesgo de fracasar. Es necesario destacar la importancia de los m√©todos, pero el √©xito del proyecto depende m√°s de la comunicaci√≥n efectiva con los interesados, el manejo de las expectativas y las personas que participan en el proyecto. 

Existen diferentes modelos y metodolog√≠as que han sido en los √∫ltimos a√±os herramientas de apoyo para el desarrollo del software. Someerville (2005), menciona que:
‚Ä¢	Modelo de desarrollo de software: es una representaci√≥n simplificada del proceso para el desarrollo de software, presentada desde una perspectiva espec√≠fica. 

‚Ä¢	Metodolog√≠a de desarrollo de software: es un enfoque estructurado para el desarrollo de software que incluye modelos de sistemas, notaciones, reglas, sugerencias de dise√±o y gu√≠as de procesos.

2.11.2 Modelos para el desarrollo de software

Como se explic√≥ en el concepto anterior, un modelo para el desarrollo de software es una representaci√≥n abstracta de un proceso. Cada modelo representa un proceso desde una perspectiva particular y as√≠ proporcione informaci√≥n parcial sobre el proceso. √âstos modelos generales no son descripciones definitivas de los procesos del software m√°s bien son abstracciones de los procesos que se pueden utilizar para el desarrollo del software. Puede pensarse en ellos como marcos de trabajo del proceso y que pueden ser adaptados para crear procesos m√°s espec√≠ficos. Los modelos que mencionaremos en este punto son:
1) El modelo en cascada. Considera las actividades fundamentales del proceso especificaci√≥n, desarrollo, validaci√≥n y evoluci√≥n. Los representa como fases separadas del proceso, tales como la especificaci√≥n de requerimientos, el dise√±o del software, la implementaci√≥n, las pruebas, etc√©tera. 

2) El modelo de desarrollo evolutivo (espiral). Este enfoque entrelaza las actividades especificaci√≥n, desarrollo y validaci√≥n. Es decir surge de un sistema inicial que se desarrolla r√°pidamente a partir de especificaciones abstractas. Bas√°ndose en las peticiones del cliente para producir un sistema que satisfaga sus necesidades. 

3) El modelo de desarrollo basado en componentes. √âste enfoque se basa en la existencia de un n√∫mero significativo de componentes reutilizables. El proceso de desarrollo se enfoca en integrar estos componentes en el sistema m√°s que en desarrollarlos desde cero. Estos tres modelos se utilizan ampliamente en la pr√°ctica actual de la ingenier√≠a del software, no se excluyen mutuamente y a menudo se utilizan juntos especialmente para el desarrollo de grandes sistemas.

A.	El modelo en cascada
Seg√∫n Royce (1970), el modelo de cascada se deriv√≥ de procesos de sistemas m√°s generales. √âste modelo se muestra en la figura 2.22 y sus principales etapas se transforman en actividades fundamentales del desarrollo:
1) An√°lisis y definici√≥n de requerimientos. Los servicios restricciones y metas del sistema se definen a partir de las consultas con los usuarios. Entonces, se definen en detalle y sirven de manera espec√≠fica al sistema. 

2) Dise√±o del sistema y del software. El proceso de dise√±o del sistema divide los requerimientos en sistemas ya sea hardware Soto. Establece una arquitectura completa del sistema, el dise√±o del software identifique describe los elementos abstractos que son fundamentales para el software y sus relaciones. 

3) Implementaciones prueba de unidades. Durante esta etapa el dise√±o del software se lleva a cabo como un conjunto de unidades de programas, la prueba de unidades implica verificar que cada una cumpla con su funci√≥n espec√≠fica. 

4) Integraci√≥n y prueba del sistema. Los programas o las unidades individuales de programas se integran y se prueban como un sistema completo para as√≠ asegurar que se cumplan los requerimientos del software, despu√©s se entrega al cliente. 

5) Funcionamiento y mantenimiento. En esta fase el sistema se instala y se pone en funcionamiento pr√°ctico el mantenimiento implica corregir errores no descubiertos en las etapas anteriores del ciclo de vida, mejorar la implementaci√≥n de las unidades del sistema y resaltar los servicios del sistema una vez que se descubren en nuevos requerimientos.

B.	El modelo de desarrollo evolutivo (espiral)
El modelo en espiral que Boehm propuso es un modelo de proceso de software evolutivo que conjuga la naturaleza iterativa de la construcci√≥n de prototipos con los aspectos controlados y sistem√°ticos del modelo en cascada. Cuando se aplica este modelo en espiral, el software se desarrolla en una serie de entregas evolutivas. Cada una de las actividades del marco de trabajo representan un segmento de la ruta en espiral. 

Este modelo se basa en la idea de desarrollar una implementaci√≥n inicial, exponi√©ndola a los comentarios del usuario y refin√°ndola a trav√©s de las diferentes versiones que se generan hasta que se desarrolle un sistema adecuado.

Las actividades de especificaci√≥n, desarrollo y validaci√≥n se entrelazan en vez de separarse, con una r√°pida retroalimentaci√≥n entre estas. Existen dos tipos de desarrollo evolutivo:
1) Desarrollo exploratorio, en este caso el objetivo del proceso es trabajar con el cliente para explorar sus requerimientos y entregar un sistema final. El desarrollo empieza con las partes del sistema que se comprenden mejor. El sistema evoluciona agregando nuevos atributos propuestos por el cliente. 

2) Prototipos desechables, el objetivo de este proceso de desarrollo evolutivo es comprender los requerimientos del cliente para as√≠ desarrollar una definici√≥n mejorada de los requerimientos para el sistema. El prototipo se centra en experimentar los requerimientos del cliente que no se comprenden del todo.

Haciendo referencia a la producci√≥n del software, un enfoque evolutivo suele ser m√°s efectivo que el enfoque en cascada, ya que satisface las necesidades inmediatas de los clientes. La ventaja de un software que se basa en un enfoque evolutivo es que las especificaciones se pueden desarrollar de forma creciente. Tan pronto como los usuarios desarrollen un mejor entendimiento de su problema, esto se puede reflejar en el software. Sin embargo, desde la perspectiva de ingenier√≠a y de gesti√≥n, el enfoque evolutivo tiene dos problemas:
1) El proceso no es visible. Esto significa que los administradores tienen que hacer entregas regulares para medir el progreso del producto. Si los sistemas se desarrollan r√°pidamente, no es rentable producir documentos que reflejen cada versi√≥n del sistema. 

2) A menudo los sistemas tienen una estructura deficiente. Esto hace referencia que los cambios continuos tienden a corromper la estructura del software. Incorporar cambios en √©l se convierte cada vez m√°s en una tarea dif√≠cil y costosa.

Para sistemas peque√±os y de tama√±o medio (hasta 500,000 l√≠neas de c√≥digo), el enfoque evolutivo de desarrollo es el mejor. Los problemas del desarrollo evolutivo se hacen particularmente agudos para sistemas grandes y complejos con un per√≠odo de vida largo, donde diferentes equipos desarrollan distintas partes del sistema. Es dif√≠cil establecer una arquitectura del sistema usando este enfoque, ya que hace dif√≠cil integrar las contribuciones de los equipos. Para sistemas grandes se recomienda un proceso mixto es decir que incorpore las mejores caracter√≠sticas del modelo en cascada y del desarrollo evolutivo. Esto implica desarrollar un prototipo desechable, utilizando un enfoque evolutivo para resolver incertidumbres en la especificaci√≥n del sistema. Puede entonces no implementarse utilizando un enfoque m√°s estructurado.

C.	El modelo de desarrollo basado en componentes
En la mayor√≠a de los proyectos de desarrollo de software existe la reutilizaci√≥n. Por lo general esto sucede informalmente cuando las personas conocen dise√±os o c√≥digos similares al requerido. Los buscan, los modifican seg√∫n lo creen necesario y los incorporan en un nuevo sistema. El enfoque evolutivo, la reutilizaci√≥n es indispensable para el desarrollo m√°s √°gil de un sistema. Esta reutilizaci√≥n es independiente del proceso de desarrollo que se utilice. Sin embargo, en los √∫ltimos a√±os ha surgido un enfoque de desarrollo de software denominado " ingenier√≠a de software basada en componentes", el cual se basa en la reutilizaci√≥n. Este enfoque se basa en la reutilizaci√≥n y se compone de una gran base de componentes de software que son reutilizables.

Aunque la etapa de especificaci√≥n de requerimientos y la revalidaci√≥n son comparables con otros procesos, las etapas intermedias en el proceso orientado a la reutilizaci√≥n son diferentes. Estas etapas son:
1) An√°lisis de componentes. En esta se buscan los componentes para implementar los con base en su especificaci√≥n. Por lo general, no existe una concordancia exacta y los componentes que se utilizan s√≥lo proporcionan parte de la funcionalidad requerida. 

2) Modificaci√≥n de requerimientos. En esta etapa los requerimientos se analizan utilizando informaci√≥n acerca de los componentes que se han descubierto. Entonces dichos componentes se modifican para reflejar los componentes disponibles, la actividad de an√°lisis de componentes se puede llevar a cabo para buscar soluciones alternativas. 

3) Dise√±o del sistema con reutilizaci√≥n. En esta fase los dise√±adores tienen en cuenta los componentes que se reutiliza y que se organizan el marco de trabajo para que los satisfaga. Si dichos componentes no est√°n disponibles se puede dise√±ar nuevos software. 

4) Desarrollo e integraci√≥n. El software que no se puede adquirir externamente se desarrolla y se integra a los componentes. En este modelo, la integraci√≥n del sistema es parte del proceso de desarrollo, m√°s que una actividad separada.

El modelo de desarrollo de software basado en componentes creado por Boehm (1988), tiene la ventaja de reducir la cantidad de software que se debe desarrollar y por ende reduce los costos y los riesgos. Tambi√©n permite una entrega m√°s r√°pida del software. Sin embargo, los compromisos a los requerimientos son inevitables y esto da lugar a un sistema que no cumpla con las necesidades reales de los usuarios. Pressman (2006), detecto que:
‚ÄúEl software de computadoras moderno se caracteriza por el cambio continuo, los tiempos de entrega son muy reducidos y una necesidad intensa de satisfacer al cliente/usuario. En muchos casos, el tiempo de llegada al mercado es el requisito de gesti√≥n m√°s importante. Si se pierde una ventana del mercado, el mismo proyecto de software puede perder su significado‚Äù.

2.11.3 Metodolog√≠as.

Las metodolog√≠as han evolucionado de manera significativa en las √∫ltimas d√©cadas como se puede observar en la tabla 2.7 Permitiendo as√≠ el √©xito o el fracaso de muchos de los sistemas desarrollados para distintas √°reas. 

Algunas de las metodolog√≠as tradicionales m√°s utilizadas para el desarrollo de software han sido, la denominada ‚Äúproceso personal de software (PSP)‚Äù y la ‚Äúproceso en equipo para el software TSP‚Äù. El TSP toma sus fundamentos en que los ingenieros deben de dar a conocer bien su trabajo y que puedan implementar un plan para poderlo realizar mejor, cuando el plan se implementa, pueden ahorrarse tiempo en realizar el trabajo y por ende generar productos de calidad. El TSP contempla dos componentes principales: 
1)	Creaci√≥n de equipo
2)	Trabajo en equipo o componente de gesti√≥n.

El TSP es una metodolog√≠a para dirigir el desarrollo de software adem√°s de establecer un entorno donde el trabajo efectivo de equipo sea normal y natural. En donde involucra a los ingenieros a desarrollar un trabajo en equipo. El desarrollo del (TSP) toma sus bases en la estrategia de calidad que propuso W. Edwards Deming (1982), con las etapas de planear, hacer, verificar y actuar. Y J.M. Juran (1988). El TSP ofrece un contexto disciplinado para el trabajo de la ingenier√≠a del software. La motivaci√≥n principal es que los ingenieros siguiendo esta metodolog√≠a pueden hacer un excelente trabajo. Los ingenieros deben estar bien capacitados, bien entrenados y deben ser bien dirigidos por un miembro calificado que entienda bien la metodolog√≠a del TSP. El objetivo principal del TSP es guiar debidamente a sus equipos de ingenieros. El TSP proporciona un proceso operacional definido para guiar a los ingenieros y administradores a trav√©s de diferentes pasos para la formaci√≥n de equipos de trabajo.

Antes de que los miembros del equipo de trabajo participen en el equipo de TSP, deben saber c√≥mo organizar bien su trabajo. Se requiere que el equipo o el personal se encuentre entrenado primero con el Personal Software Process (PSP). Esto le permite a los ingenieros obtener el conocimiento en saber c√≥mo crear un plan detallado, reuniendo y usando procesos de datos, usando valores obtenidos para seguir un proyecto en donde puedan medir y dirigir la calidad del producto. El objetivo del PSP es poner a los profesionales de software a cargo de su trabajo y para que se sientan personalmente responsables de la calidad de los productos que producen. PSP puede trabajar a la par con los objetivos de la metodolog√≠a (TSP) son:
1) Proporcionar un entorno de equipo que apoya el trabajo de la PSP 
2) Construir y mantener un equipo autodirigido.

PSP y TSP son potentes herramientas que proporcionan los conocimientos necesarios, la disciplina y el compromiso necesarios para los proyectos de software exitoso. Se sabe que en nuestro pa√≠s para que se pueda producir software con calidad se debe de adoptar un nivel de madurez de procesos alto, es decir, que sea equiparable a los niveles internacionales, esto es a trav√©s del CMMI (Capability Maturity Model Integration), pero es dif√≠cil implementarlo en organizaciones peque√±as. En M√©xico se cuenta con la norma mexicana basada en MoProsoft (Modelo de Procesos para la Industria del Software), pero esta se centra en los procesos de las organizaciones pero no en las personas, que son los m√°s importantes para que ellas funcionen. En M√©xico no solamente se debe incrementar el nivel de madurez en los procesos de la industria de Software, si no que, se debe incluir el mejoramiento del elemento b√°sico que sustente la industria, que son las personas.

Con PSP, los desarrolladores utilizan procesos bien definidos y medibles. Se toma informaci√≥n de tama√±o, tiempo y defectos al momento de realizar el trabajo. Se utilizan los datos para: planear y monitorear el trabajo, as√≠ como administrar la calidad de los productos que se producen y medir el desempe√±o. TSP ha permitido resolver problemas t√≠picos de negocio: como predecir el costo y tiempo, mejorar la productividad y establecer ciclos de desarrollo para generar la mejora en la calidad de los productos. PSP/TSP mejoran el desempe√±o tanto de equipos como de individuos; es disciplinado y dirigida en todo su desarrollo a la planeaci√≥n; provee beneficios inmediatos y medibles; acelera las iniciativas de mejora de los procesos organizacionales. Con TSP, los equipos encuentran y reparan defectos en etapas tempranas del proceso de desarrollo. Esto reduce de manera importante el tiempo de pruebas.

2.11.3.1 Metodolog√≠as para el desarrollo √°gil del software.
Actualmente los negocios operan en un entorno global que cambia r√°pidamente. Tienen que responder a nuevas oportunidades y mercados, condiciones econ√≥micas cambiantes y la aparici√≥n de productos y servicios competidores. El software es parte de casi todas las operaciones de negocio, por lo que es fundamental que el software nuevo se desarrolle r√°pidamente para aprovechar nuevas oportunidades y responder a la presi√≥n competitiva. Actualmente el desarrollo y entrega de manera r√°pida son los requerimientos m√°s cr√≠ticos de los sistemas. De hecho, muchas organizaciones est√°n dispuestas a obtener una p√©rdida en la calidad del software y en el compromiso sobre los requerimientos en favor de una entrega r√°pida del software.

Los procesos de desarrollo del software basados en una completa especificaci√≥n de los requerimientos, dise√±o, construcci√≥n y pruebas del sistema no se ajustan al desarrollo r√°pido de aplicaciones. Cuando los requerimientos cambian o se descubren problemas con ellos, el dise√±o o implementaci√≥n del sistema se tiene que volver a realizar o probar. Como consecuencia, normalmente se prolonga en el tiempo un proceso en cascada convencional y el software definitivo se entrega mucho tiempo despu√©s al cliente con el que inicialmente se pact√≥. En un entorno de negocios tan cambiante, esto puede causar verdaderos problemas. Para cuando est√© disponible el software, la raz√≥n original de su adquisici√≥n puede ser que haya cambiado de forma radical que en realidad √©ste sea in√∫til. Dicha metodolog√≠a combina una filosof√≠a y un conjunto de directrices de desarrollo. La filosof√≠a busca la satisfacci√≥n del cliente y la entrega temprana de software incremental, equipos peque√±os con alta motivaci√≥n, m√©todos informales y una simplicidad general del desarrollo. Los procesos de desarrollo r√°pido de software est√°n dise√±ados para producir software √∫til de forma r√°pida. Generalmente, son procesos interactivos en los que se entrelazan la especificaci√≥n, el dise√±o, el desarrollo y las pruebas.

En los a√±os 80 y principios de los 90, exist√≠a una opini√≥n general de que la mejor forma de obtener un software de calidad era a trav√©s de una planificaci√≥n cuidadosa del proyecto y de la utilizaci√≥n de m√©todos de an√°lisis y dise√±o soportados por herramientas CASE (Computer Aided Software Engineering). Esta opini√≥n ven√≠a fundamentalmente de la comunidad de ingenieros de software implicado en el desarrollo de grandes sistemas y que normalmente se compon√≠an de un gran n√∫mero de programas individuales. Este software era desarrollado por grandes equipos que trabajaban para compa√±√≠as diferentes y que a menudo estaban dispersos geogr√°ficamente y trabajaban durante largos periodos de tiempo.

Sin embargo, cuando este enfoque era aplicado a sistemas de negocios peque√±os y de tama√±o medio, el esfuerzo invertido era tan grande que algunas veces dominaba el proceso de desarrollo del software, es decir, se pasaba m√°s tiempo pensando en c√≥mo se deb√≠a desarrollar el sistema que en c√≥mo programar el desarrollo y c√≥mo hacer las pruebas pertinentes. El descontento de esto produjo que varios desarrolladores propusieran nuevos m√©todos que eran m√°s √°giles. Aunque estos m√©todos se basan principalmente en la noci√≥n del desarrollo y en las entregas incrementales, proponen procesos diferentes para alcanzar el objetivo.

En una reuni√≥n celebrada en febrero de 2001 en Utah-EEUU, nace el t√©rmino "√°gil" aplicado al desarrollo de software. En esta reuni√≥n participan un grupo de diecisiete expertos de la industria del software, incluyendo algunos de los creadores o impulsores de metodolog√≠as de software. Su objetivo fue esbozar los valores y principios que deber√≠an permitir a los equipos a desarrollar software r√°pidamente y respondiendo a los cambios que podr√≠an surgir a lo largo de los proyectos. Se pretend√≠a ofrecer una alternativa a los procesos de desarrollo de software tradicionales, caracterizados por ser r√≠gidos y dirigidos por la documentaci√≥n que se genera en cada una de las actividades desarrolladas. Varias de las denominadas metodolog√≠as √°giles ya estaban siendo utilizadas con √©xito en proyectos reales, pero les faltaba una mayor difusi√≥n y reconocimiento. Tras esta reuni√≥n se cre√≥ ‚ÄúThe Agile Alliance‚Äù (2001), una organizaci√≥n, sin √°nimo de lucro, dedicada a promover los conceptos relacionados con el desarrollo √°gil de software y ayudar a las organizaciones para que adopten dichos conceptos.

El punto de partida fue el manifiesto √°gil, un documento que resume la filosof√≠a "√°gil". A continuaci√≥n en la tabla 2.8, vamos a enumerar las principales diferencias de una Metodolog√≠a √Ågil respecto a las Metodolog√≠as Tradicionales (llamadas peyorativamente ‚Äúno √°giles‚Äù o ‚Äúpesadas‚Äù). Estas diferencias que no se refieren s√≥lo al proceso en s√≠, sino tambi√©n al contexto de equipo y organizaci√≥n que es m√°s favorable a cada uno de estas filosof√≠as de procesos de desarrollo de software. 

Si bien la idea de participaci√≥n del cliente en el proceso de desarrollo es atractiva, el √©xito depender√° de tener un cliente que est√© dispuesto y lo m√°s importante pueda pasar tiempo con el equipo de desarrollo para as√≠ presentar a todos los implicados del sistema, los clientes est√°n sometidos a otras presiones y no pueden participar plenamente en el desarrollo del software. El cliente es el punto clave, solicita los requerimientos que se deben de incluir. Los miembros individuales del equipo puede no tener la personalidad propia para una participaci√≥n intensa. Por lo tanto, es posible que no se relacionen adecuadamente con los otros miembros del equipo. Priorizar los cambios puede ser extremadamente dif√≠cil, espec√≠ficamente en sistemas en los que existen muchos implicados.

Mantener la simplicidad requiere un trabajo extra. Cuando se trabaja bajo presi√≥n por las agendas de entregas, los miembros del equipo no pueden tener a tiempo las especificaciones del sistema. Por consiguiente los m√©todos √°giles tienen que depender de contratos donde el cliente paga por el tiempo necesario para el desarrollo del sistema en lugar de por el desarrollo de un conjunto de requerimientos espec√≠ficos. Siempre y cuando el proyecto vaya caminando en forma, esto beneficiar√° tanto al cliente como al desarrollador. Todos los m√©todos tienen l√≠mites y los m√©todos √°giles son apropiados para algunos tipos de desarrollo de sistemas. Son los m√°s id√≥neos para el desarrollo de sistemas para peque√±os negocios y medianas empresas. No son adecuados para el desarrollo de sistemas a gran escala con equipos de desarrollo situados en diferentes lugares geogr√°ficamente hablando ya que puede haber complejas interacciones con otros sistemas o hardware.

Los m√©todos √°giles no se deben de utilizar para el desarrollo de sistemas cr√≠ticos en los que es necesario generar un an√°lisis detallado de todos los requerimientos del sistema para as√≠ comprender mejor sus implicaciones de seguridad o de protecci√≥n. El crecimiento de los m√©todos √°giles y su penetraci√≥n ocurre a un ritmo pocas veces visto en la industria: en tres o cuatro a√±os, seg√∫n el Cutter Consortium, el 50% de las empresas define como ‚Äú√°giles‚Äù m√°s de la mitad de los m√©todos empleados en sus proyectos (Charette, 2004). Algunas de las metodolog√≠as agiles mas usadas en la actualidad se describen a continuaci√≥n.

‚Ä¢	Metodolog√≠a XP programaci√≥n extrema
La programaci√≥n extrema XP es posiblemente el m√©todo √°gil m√°s conocido y ampliamente utilizado. El nombre de XP fue acu√±ado por Beck (2000), debido a que el enfoque fue desarrollado utilizando las mejores pr√°cticas del desarrollo iterativo y con la participaci√≥n extrema del cliente. La programaci√≥n extrema (XP), que algunos consideran una innovaci√≥n extraordinaria y otros creen c√≠nica (Rakitin, 2001). En la metodolog√≠a extrema, todos los requerimientos se expresan como escenarios (llamados historias de usuario), los cuales se implementan directamente como una serie de tareas. Los programadores trabajan en parejas y desarrollan pruebas para cada tarea antes de escribir el c√≥digo. Todas las pruebas se deben ejecutar satisfactoriamente cuando el c√≥digo nuevo se integra al sistema. Existe un peque√±o espacio de tiempo entre las entregas del sistema. 

El desarrollo incremental se lleva a trav√©s de entregas peque√±as y frecuentes del sistema y por medio de un enfoque que sirve para la descripci√≥n de requerimientos basado en las historias del clientes o escenarios que pueden ser la base para el proceso de planificaci√≥n.

La participaci√≥n del cliente se lleva a cabo a trav√©s del compromiso y del tiempo completo del cliente en el equipo de desarrollo. Los colaboradores directos de los clientes participan en el desarrollo y son los responsables de definir las pruebas necesarias que servir√°n para la aceptaci√≥n del sistema. El inter√©s de las personas, en vez de los procesos, se lleva a trav√©s de la programaci√≥n en parejas, la propiedad colectiva del c√≥digo y un proceso de desarrollo sostenible que no implique excesivas jornadas de trabajo. El cambio se lleva a cabo a trav√©s de las entregas regulares del sistema, un desarrollo previamente probado y la integraci√≥n continua. El mantenimiento se lleva a cabo a trav√©s de una recta actualizaci√≥n constante para mejorar la calidad del c√≥digo y la utilizaci√≥n de dise√±os sencillos que no prev√©n cambios futuros en el sistema.

En XP, los clientes est√°n implicados en la especificaci√≥n y establecimiento de prioridades de los requerimientos del sistema. Dichos requerimientos no se especifica como una lista de funciones requeridas en el sistema. M√°s bien, los clientes del sistema son parte fundamental del equipo de desarrollo esto permite que discutan escenarios con todos los miembros del equipo. Desarrollar conjuntamente tarjetas de historia (story card) que recogen las necesidades del cliente. Por ende el equipo de desarrollo intentar√° implementar esos escenarios en una entrega futura del software. Un punto fundamental en la ingenier√≠a del soporte tradicional es que se debe de dise√±ar para futuros. Esto es que se deben de prever los cambios futuros y dise√±ar √©ste de forma que tales cambios se puedan implementar f√°cilmente. La metodolog√≠a XP ha descartado este principio partiendo del hecho de que dise√±ar para el cambio es a menudo un esfuerzo in√∫til. Con frecuencia los cambios previstos nunca se materializa y realmente se efect√∫an peticiones de cambios completamente diferentes. La metodolog√≠a extrema aborda este problema sugiriendo que se debe revisar constantemente el software. Esto es, que el equipo de programaci√≥n busca posibles mejoras y las implementa de forma inmediata as√≠ lo que se busca es que siempre sea f√°cil de entender y cambiar cuando simplemente nuevas historias.

‚Ä¢	Metodolog√≠a SCRUM
A pesar de que la metodolog√≠a XP recibe la mayor atenci√≥n bibliogr√°fica, las organizaciones est√°n enfocando su atenci√≥n en la metodolog√≠a √°gil denominada SCRUM (Schwaber & Shuterland, 2011) (Shuterland, 2012), la cual aplica las mismas premisas conceptuales que XP pero para resolver un problema ligeramente distinto como es el de desarrollo evolutivo de aplicaciones. SCRUM es una metodolog√≠a √°gil y flexible que sirve para gestionar el desarrollo de software, cuyo principal objetivo es maximizar el retorno de la inversi√≥n para su empresa. Se basa principalmente en construir la funcionalidad de mayor valor para el cliente y en los principios de inspecci√≥n continua, adaptaci√≥n, auto-gesti√≥n e innovaci√≥n. 

Con SCRUM el cliente es pieza fundamental en el desarrollo de software, se entusiasma y se compromete con el proyecto dado que lo ve crecer iteraci√≥n a iteraci√≥n. Asimismo le permite en cualquier momento realinear el software con los objetivos de negocio de su empresa, ya que puede introducir cambios funcionales o de prioridad en el inicio de cada nueva iteraci√≥n. Esta forma de trabajo promueve la innovaci√≥n, motivaci√≥n y el compromiso del equipo que forma parte del proyecto, por lo que los profesionales encuentran un √°mbito propicio para desarrollar sus capacidades. SCRUM genera algunas ventajas a diferencia de otras metodolog√≠as agiles entre ellas:
‚Ä¢	Cumplimento de expectativas: El cliente establece sus expectativas indicando el valor que aporta a cada requisito / historia del proyecto, el equipo los estima y con esta informaci√≥n el propietario del producto establece su prioridad. 

‚Ä¢	Flexibilidad a cambios: Genera una alta capacidad de reacci√≥n ante los cambios de requerimientos generados por necesidades del cliente o evoluciones del mercado. La metodolog√≠a est√° dise√±ada para adaptarse a los cambios de requerimientos que conllevan los proyectos complejos. 

‚Ä¢	Reducci√≥n del tiempo: El cliente puede empezar a utilizar las funcionalidades m√°s importantes del proyecto antes de que est√© finalizado por completo. 

‚Ä¢	Mayor calidad del software: La forma de trabajo y la necesidad de obtener una versi√≥n funcional despu√©s de cada iteraci√≥n, ayuda a la obtenci√≥n de un software de calidad superior. 

‚Ä¢	Mayor productividad: Se consigue entre otras razones, gracias a la eliminaci√≥n de la burocracia y a la motivaci√≥n del equipo que proporciona el hecho de que sean aut√≥nomos para organizarse. 

‚Ä¢	Maximiza el retorno de la inversi√≥n (ROI): Producci√≥n de software √∫nicamente con las prestaciones que aportan mayor valor de negocio gracias a la priorizaci√≥n por retorno de inversi√≥n. 

‚Ä¢	Predicciones de tiempos: Mediante esta metodolog√≠a se conoce la velocidad media del equipo por sprint (los llamados puntos historia), con lo que consecuentemente, es posible estimar f√°cilmente para cuando se dispondr√° de una determinada funcionalidad que todav√≠a est√° retrasada. 

‚Ä¢	Reducci√≥n de riesgos: El hecho de llevar a cabo las funcionalidades de m√°s valor en primer lugar y de conocer la velocidad con que el equipo avanza en el proyecto, permite despejar riesgos eficazmente de manera anticipada.

La totalidad de los requerimientos a desarrollar, denominados historias de usuario (‚Äúuser stories‚Äù) son divididos en grupos en funci√≥n de su prioridad relativa para luego ser implementados en ciclos de esfuerzos relativamente cortos llamados ‚Äúsprints‚Äù; las tareas son organizadas en el equipo de tal manera que las asignaciones y prioridades se revisan diariamente en una reuni√≥n breve llamada ‚ÄúSCRUM‚Äù que le da su nombre la metodolog√≠a. En este enfoque se siguen los principales criterios del manifiesto generando as√≠ liberaciones parciales incrementales del producto que se esta desarrollando. La evidencia es consistente que al abrazar la hoja de ruta y comprometer las inversiones necesarias para desplegar formalmente esta metodolog√≠a tambi√©n se abordan al mismo tiempo aspectos clave del despliegue de pr√°cticas maduras de proceso.‚Ä® 
En tal sentido SCRUM ha sido exitosamente comparada contra los requisitos a satisfacer para alcanzar una de evaluaci√≥n bajo niveles 2 y 3 del modelo CMMI (Shuterland, et al, 2008), (Turner & Jain, 2002). Demostrando as√≠ que la ejecuci√≥n rigurosa satisface a la mayor√≠a de los objetivos necesarios que sirven para obtener estos niveles; las pocas √°reas del proceso no cubiertas directamente por no ser requeridos por SCRUM son en la pr√°ctica un requisito para el correcto desempe√±o de una organizaci√≥n dedicada a la construcci√≥n de software. 

‚Ä¢	Desarrollo adaptativo de software (DAS)
El desarrollo adaptativo software (DAS) lo propuso Jim Highsmith en 1998 como una t√©cnica para construir software y sistemas complejos. Los apoyos filos√≥ficos del DAS se enfocan en la colaboraci√≥n humana y la organizaci√≥n propia del equipo. Un enfoque de desarrollo √°gil y adaptativo basado en la colaboraci√≥n es " una fuente de orden en las complejas interacciones entre disciplina e ingenier√≠a". El define el ciclo de vida del DAS, como se muestra en la figura 2.29 el cual incorpora tres fases principales:
1)	Especulaci√≥n; en esta fase se inicia el proyecto y se conduce el ciclo adaptativo de planeaci√≥n. Este √∫ltimo utiliza informaci√≥n de inicio del proyecto, es decir, el enunciado de la misi√≥n del cliente, restricciones del proyecto y los requisitos b√°sicos. Esto permite definir el conjunto de ciclos de lanzamiento que se requerir√°n para el proyecto. 

2)	Colaboraci√≥n; la gente motivada trabaja de una forma que multiplica su talento y sus salidas creativas m√°s all√° de sus n√∫meros absolutos. Este enfoque de colaboraci√≥n es un tema recurrente en todos los m√©todos √°giles, pero la cooperaci√≥n no es f√°cil. No solamente es la comunicaci√≥n, o que la comunicaci√≥n es parte de ella. No s√≥lo es un asunto de trabajo en equipo, aunque un equipo cuajado es esencial para la presencia de la colaboraci√≥n real. No es un rechazo al individualismo ya que la creatividad individual representa un papel importante en el pensamiento de colaboraci√≥n. Esto es, por encima de todo, una cuesti√≥n de confianza. Las personas que trabajan juntas deben confiar entre s√≠ para:
a) Criticar de forma constructiva
b) Ayudar sin resentimientos
c) Trabajar m√°s duro de lo que ya lo hace
d) Tener el conjunto de actitudes para contribuir al trabajo curso
e) Comunicar los problemas o preocupaciones en una forma que conduzca a la acci√≥n efectiva
3) Aprendizaje; como miembros de un equipo de DAS se comienzan a desarrollar los componentes integrantes de un ciclo adaptativo, la importancia radica en el aprendizaje y en el progreso a trav√©s de un ciclo completo. De hecho Highsmith (2002), argumenta que los desarrolladores de software a menudo sobreestima su comprensi√≥n (de la tecnolog√≠a, el proceso y el proyecto), y que el aprendizaje les podr√© ayudar a mejorar su grado de entendimiento real. Los equipos del DAS aprenden de tres maneras:
a)	Grupos enfocados. El cliente o los usuarios finales proporcionan retroalimentaci√≥n sobre los incrementos de software que se entregan. Esto indica en forma directa la satisfacci√≥n o la insatisfacci√≥n de las necesidades del negocio. 

b)	Revisiones t√©cnicas formales. Los miembros del equipo del DAS revisan los componentes del software desarrollado mientras mejoran su calidad y su aprendizaje. 

c)	Post mortem. El equipo de DAS se vuelve introspectivo al vigilar su propio desempe√±o y proceso con el prop√≥sito de aprender acerca de su enfoque y despu√©s mejorarlo. 

Es importante destacar que la filosof√≠a del DAS es meritoria sin importar el modelo del proceso empleado. La din√°mica de la organizaci√≥n propia los equipos, la colaboraci√≥n interpersonal y el aprendizaje individual conducen a los grupos de proyectos de software con una mayor posibilidad de √©xito
=======
Ingenier√≠a de Requisitos
Ingenier√≠a de Requisitos, es el proceso de desarrollar una especificaci√≥n de Software. Las especificaciones pretenden comunicar las necesidades del sistema del cliente a los desarrolladores del sistema. Trata de los principios, m√©todos, t√©cnicas y herramientas que permiten descubrir, documentar y mantener los requisitos para sistemas basados en computadora, de forma sistem√°tica y repetible.
Importancia
Los principales beneficios que se obtienen de la Ingenier√≠a de Requisitos son:

Permite gestionar las necesidades del proyecto en forma estructurada: Cada actividad de la Ingenier√≠a de Requisitos consiste de una serie de pasos organizados y bien definidos.
Mejora la capacidad de predecir cronogramas de proyectos, as√≠ como sus resultados: La Ingenier√≠a de Requisitos proporciona un punto de partida para controles subsecuentes y actividades de mantenimiento, tales como estimaci√≥n de costos, tiempo y recursos necesarios.
Disminuye los costos y retrasos del proyecto: Muchos estudios han demostrado que reparar errores por un mal desarrollo no descubierto a tiempo, es sumamente caro; especialmente aquellas decisiones tomadas durante la Especificaci√≥n de Requisitos.
Mejora la calidad del software: La calidad en el software tiene que ver con cumplir un conjunto de requisitos (Funcionalidad, Facilidad de Uso, Confiabilidad Desempe√±o, etc.).
Mejora la comunicaci√≥n entre equipos: La especificaci√≥n de requisitos representa una forma de consenso entre clientes y desarrolladores. Si este consenso no ocurre, el proyecto no ser√° exitoso.
Evita rechazos de usuarios finales: La Ingenier√≠a de Requisitos obliga al cliente a considerar sus requisitos cuidadosamente y revisarlos dentro del marco del problema, por lo que se le involucra durante todo el desarrollo del proyecto.
Actividades
Existen cuatro actividades b√°sicas (extracci√≥n, an√°lisis, especificaci√≥n y validaci√≥n) que se tienen que llevar a cabo para completar el proceso. Estas actividades ayudan a reconocer la importancia que tiene, para el desarrollo de un proyecto de software, realizar una especificaci√≥n y administraci√≥n adecuada de los requisitos de los clientes o usuarios.

Extracci√≥n: Esta fase representa el comienzo de cada ciclo. Extracci√≥n es el nombre com√∫nmente dado a las actividades involucradas en el descubrimiento de los requisitos del sistema.
An√°lisis: Sobre la base de la extracci√≥n realizada previamente, comienza esta fase. Usualmente se hace un an√°lisis luego de haber producido un bosquejo inicial del documento de requisitos; aqu√≠ se leen los requisitos, se concept√∫an, se investigan, se intercambian ideas con el resto del equipo, se resaltan los problemas, se buscan alternativas y soluciones, y luego se van fijando reuniones con el cliente para discutir los requisitos.
Especificaci√≥n: En esta fase se documentan los requisitos acordados con el cliente, en un nivel apropiado de detalle. En la pr√°ctica, esta etapa se va realizando conjuntamente con el an√°lisis, pero se podr√≠a decir que la Especificaci√≥n es el ‚Äúpasar en limpio‚Äù el an√°lisis realizado previamente aplicando t√©cnicas y/o est√°ndares de documentaci√≥n, como la notaci√≥n UML.
Validaci√≥n: La validaci√≥n es la etapa final de la IR. Su objetivo es verificar todos los requisitos que aparecen en el documento especificado para asegurarse que representan una descripci√≥n, por lo menos, aceptable del sistema que se debe implementar. Esto implica verificar que los requisitos sean consistentes y que est√©n completos.
La validaci√≥n representa un punto de control interno y externo; interno, porque se debe verificar internamente lo que se est√° haciendo, y externo, porque se debe validar con el cliente.
Herramientas
Existen diversas t√©cnicas y herramientas que se utilizan para llevar a cabo cada una de las actividades del proceso de Ingenier√≠a de Requisitos, una de las razones por las cuales surgen los errores a la hora del levantamiento es la existencia de una gama de herramientas. No existe una especie de gu√≠a para el uso de los desarrolladores, estos utilizan incluso en la captura m√°s de una t√©cnica en cada de las actividades que contiene el proceso.
Herramientas m√°s Usadas

Entrevistas y cuestionarios: Las entrevistas y cuestionarios se emplean para reunir informaci√≥n proveniente de personas o grupos, informaci√≥n que se obtiene conversando con el encuestado. Las preguntas suelen distinguirse en dos categor√≠as: abiertas y cerradas. Las preguntas abiertas permiten que los encuestados respondan con su propia terminolog√≠a, mientras que las preguntas cerradas predeterminan todas las posibles respuestas y el interrogado elige entre las opciones presentadas.
Grabaciones de video y de audio: B√°sicamente existen dos formas de utilizar las grabaciones: como registro y apoyo de las entrevistas, y para analizar alg√∫n proceso en particular. En cuanto a su funci√≥n de apoyo, es importante porque permite centrar la atenci√≥n en la entrevista en s√≠, en vez de distraerse tomando notas de todo lo que se dice. Cuando se trata de analizar alg√∫n proceso en particular, su ayuda es inestimable (sobre todo las filmaciones de video) porque permite ver y analizar en detalle ese proceso la cantidad de veces que sea necesario.
Brainstorming (tormenta de ideas): Este es un modelo que se usa para generar ideas. La intenci√≥n en su aplicaci√≥n es la de generar la m√°xima cantidad posible de requisitos para el sistema. No hay que detenerse en pensar si la idea es o no del todo utilizable.

Herramientas Case

Las herramientas CASE (Computer Aided Software Engineering, IngenierÌa de Software Asistida por Computadora) son diversas aplicaciones inform·ticas o programas inform·ticos destinadas a aumentar la productividad en el desarrollo de software reduciendo el costo de las mismas en tÈrminos de tiempo y de dinero.

Estas herramientas pueden ayudar en todos los aspectos del ciclo de vida de desarrollo del software en tareas como el proceso de realizar un diseÒo del proyecto, c·lculo de costos, implementaciÛn de parte del cÛdigo autom·ticamente con el diseÒo dado, compilaciÛn autom·tica, documentaciÛn o detecciÛn de errores entre otras. Ya en los aÒos 70 un proyecto llamado ISDOS diseÒÛ un lenguaje y por lo tanto un producto que analizaba la relaciÛn existente entre los requisitos de un problema y las necesidades que estos generaban, el lenguaje en cuestiÛn se denominaba PSL (Problem Statement Language) y la aplicaciÛn que ayudaba a buscar las necesidades de los diseÒadores PSA (Problem Statement Analyzer).

Aunque Èsos son los inicios de las herramientas inform·ticas que ayudan a crear nuevos proyectos inform·ticos, la primera herramienta CASE fue Excelerator que saliÛ a la luz en el aÒo 1984 y trabajaba bajo una plataforma PC.

Las herramientas CASE alcanzaron su techo a principios de los aÒos 90. En la Època en la que IBM habÌa conseguido una alianza con la empresa de software AD/Cycle para trabajar con sus mainframes o computadoras centrales, estos dos gigantes trabajaban con herramientas CASE que abarcaban todo el ciclo de vida del software. Pero poco a poco los mainframes han ido siendo menos utilizados y actualmente el mercado de las Big CASE ha muerto completamente abriendo el mercado de diversas herramientas m·s especÌficas para cada fase del ciclo de vida del software.

Objetivos
Mejorar la productividad del software.
Aumentar la calidad del software.
Reducir el tiempo y costo de desarrollo y mantenimiento de los sistemas inform·ticos.
Mejorar la planificaciÛn de un proyecto.
Aumentar la biblioteca de conocimiento inform·tico de una empresa ayudando a la b˙squeda de soluciones para los requisitos.
Automatizar el desarrollo del software, la documentaciÛn, la generaciÛn de cÛdigo, las pruebas de errores y la gestiÛn del proyecto.
Ayuda a la reutilizaciÛn del software, portabilidad y estandarizaciÛn de la documentaciÛn.
GestiÛn global en todas las fases de desarrollo de software con una misma herramienta.
Facilitar el uso de las distintas metodologÌas propias de la ingenierÌa del software.

Ejemplos:
case1.jpg ---UML
case2.jpg ---easycase
