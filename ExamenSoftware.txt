<<<<<<< HEAD
Ingeniería de software

Según Sommerville (2005), para muchas personas el software son solo programas de computadora, sin embargo nos comenta que son todos aquellos documentos asociados a la configuración de datos que se necesitan para hacer que estos programas operen de manera adecuada. Estos productos de software se desarrollan para algún cliente en particular o para un mercado en general. Para el diseño y desarrollo de proyectos de software se aplican metodologías, modelos y técnicas que permiten resolver los problemas. En los años 50 no existían metodologías de desarrollo, el desarrollo estaba a cargo de los propios programadores. De ahí la importancia de contar con analistas y diseñadores que permitieran un análisis adecuado de las necesidades que se deberían de implementar. 

Aun así los resultados eran impredecibles, no se sabía la fecha exacta en que concluiría un proyecto de software, no había forma de controlar las actividades que se estaban desarrollando. Tampoco se contaba con documentación estandarizada. El nacimiento de técnicas estructuradas es lo que da origen al desarrollo de aplicaciones a través de métodos de ingeniería. La informática aporta herramientas y procedimientos que se apoyan en la ingeniería de software con el fin de mejorar la calidad de los productos de software, aumentar la productividad y trabajo de los ingenieros desarrolladores de software, facilitar el control del proceso de desarrollo de software y suministrar a los desarrolladores las bases para construir software de alta calidad en una forma eficiente, Gacitúa(2003). 

El objetivo principal que busca la ingeniería de software es convertir el desarrollo de software en un proceso formal, con resultados predecibles, que permitan obtener un producto final de alta calidad y satisfaga las necesidades y expectativas del cliente. Según Gacitúa (2003), la Ingeniería de Software es un proceso intensivo de conocimiento, que abarca la captura de requerimientos, diseño, desarrollo, prueba, implantación y mantenimiento. Generalmente a partir de un complejo esquema de comunicación en el que interactúan usuarios y desarrolladores, el usuario brinda una concepción de la funcionalidad esperada y el desarrollador especifica esta funcionalidad a partir de esta primera concepción mediante aproximaciones sucesivas. Este ambiente de interacción motiva la búsqueda de estrategias robustas para garantizar que los requisitos del usuario serán descubiertos con precisión y que además serán expresados en una forma correcta y sin ambigüedad, que sea verificable, trazable y modificable. 

El término ingeniería del software empezó a usarse a finales de la década de los sesenta, para expresar el área de conocimiento que se estaba desarrollando en torno a las problemáticas que ofrecía el software. En esa época, el crecimiento espectacular de la demanda de sistemas de computación cada vez más y más complejos, asociado a la inmadurez del propio sector informático (totalmente ligado al electrónico) y a la falta de métodos y recursos, provocó lo que se llamó la crisis del software. Durante esa época muchos proyectos importantes superaban con creces los presupuestos y fechas estimados. La crisis del software finalizó pues se comenzó a progresar en los procesos de diseño y metodologías. 

Según Silva (2001) desde 1985 hasta el presente, han ido apareciendo herramientas, metodologías y tecnologías que se presentaban como la solución definitiva al problema de la planificación, previsión de costos y aseguramiento de la calidad en el desarrollo de software. La dificultad propia de los nuevos sistemas, y su impacto en las organizaciones, ponen de manifiesto las ventajas, y en muchos casos la necesidad, de aplicar una metodología formal para llevar a cabo los proyectos de este tipo. La ingeniería de software es una tecnología multicapa en la que, según Pressman (2005), se pueden identificar: los métodos, el proceso (que es el fundamento de la Ingeniería de Software, es la unión que mantiene juntas las capas de la tecnología) y las herramientas (soporte automático o semiautomático para el proceso y los métodos). Como disciplina, establece el proceso de definición de requerimientos en una sucesión de actividades mediante las cuales lo que debe hacerse, se modela y analiza (Choque, 2001). 

Una parte importante de la ingeniería de software es el desarrollo de metodologías y modelos. En la actualidad ha habido muchos esfuerzos que se han encaminado al estudio de los métodos y técnicas para lograr una aplicación más eficiente de las metodologías y lograr sistemas más eficientes y de mayor calidad con la documentación necesaria en perfecto orden y en el tiempo requerido. Gacitúa (2003), plantea que una metodología impone un proceso de forma disciplinada sobre el desarrollo de software con el objetivo de hacerlo más predecible y eficiente. Una metodología define una representación que permite facilitar la manipulación de modelos, y la comunicación e intercambio de información entre todas las partes involucradas en la construcción de un sistema. 

Goncalves (2005) plantea que la experiencia ha demostrado que los proyectos exitosos son aquellos que son administrados siguiendo una serie de procesos que permiten organizar y luego controlar el proyecto, considerando válido destacar que aquellos procesos que no sigan estos lineamientos corren un alto riesgo de fracasar. Es necesario destacar la importancia de los métodos, pero el éxito del proyecto depende más de la comunicación efectiva con los interesados, el manejo de las expectativas y las personas que participan en el proyecto. 

Existen diferentes modelos y metodologías que han sido en los últimos años herramientas de apoyo para el desarrollo del software. Someerville (2005), menciona que:
•	Modelo de desarrollo de software: es una representación simplificada del proceso para el desarrollo de software, presentada desde una perspectiva específica. 

•	Metodología de desarrollo de software: es un enfoque estructurado para el desarrollo de software que incluye modelos de sistemas, notaciones, reglas, sugerencias de diseño y guías de procesos.

2.11.2 Modelos para el desarrollo de software

Como se explicó en el concepto anterior, un modelo para el desarrollo de software es una representación abstracta de un proceso. Cada modelo representa un proceso desde una perspectiva particular y así proporcione información parcial sobre el proceso. Éstos modelos generales no son descripciones definitivas de los procesos del software más bien son abstracciones de los procesos que se pueden utilizar para el desarrollo del software. Puede pensarse en ellos como marcos de trabajo del proceso y que pueden ser adaptados para crear procesos más específicos. Los modelos que mencionaremos en este punto son:
1) El modelo en cascada. Considera las actividades fundamentales del proceso especificación, desarrollo, validación y evolución. Los representa como fases separadas del proceso, tales como la especificación de requerimientos, el diseño del software, la implementación, las pruebas, etcétera. 

2) El modelo de desarrollo evolutivo (espiral). Este enfoque entrelaza las actividades especificación, desarrollo y validación. Es decir surge de un sistema inicial que se desarrolla rápidamente a partir de especificaciones abstractas. Basándose en las peticiones del cliente para producir un sistema que satisfaga sus necesidades. 

3) El modelo de desarrollo basado en componentes. Éste enfoque se basa en la existencia de un número significativo de componentes reutilizables. El proceso de desarrollo se enfoca en integrar estos componentes en el sistema más que en desarrollarlos desde cero. Estos tres modelos se utilizan ampliamente en la práctica actual de la ingeniería del software, no se excluyen mutuamente y a menudo se utilizan juntos especialmente para el desarrollo de grandes sistemas.

A.	El modelo en cascada
Según Royce (1970), el modelo de cascada se derivó de procesos de sistemas más generales. Éste modelo se muestra en la figura 2.22 y sus principales etapas se transforman en actividades fundamentales del desarrollo:
1) Análisis y definición de requerimientos. Los servicios restricciones y metas del sistema se definen a partir de las consultas con los usuarios. Entonces, se definen en detalle y sirven de manera específica al sistema. 

2) Diseño del sistema y del software. El proceso de diseño del sistema divide los requerimientos en sistemas ya sea hardware Soto. Establece una arquitectura completa del sistema, el diseño del software identifique describe los elementos abstractos que son fundamentales para el software y sus relaciones. 

3) Implementaciones prueba de unidades. Durante esta etapa el diseño del software se lleva a cabo como un conjunto de unidades de programas, la prueba de unidades implica verificar que cada una cumpla con su función específica. 

4) Integración y prueba del sistema. Los programas o las unidades individuales de programas se integran y se prueban como un sistema completo para así asegurar que se cumplan los requerimientos del software, después se entrega al cliente. 

5) Funcionamiento y mantenimiento. En esta fase el sistema se instala y se pone en funcionamiento práctico el mantenimiento implica corregir errores no descubiertos en las etapas anteriores del ciclo de vida, mejorar la implementación de las unidades del sistema y resaltar los servicios del sistema una vez que se descubren en nuevos requerimientos.

B.	El modelo de desarrollo evolutivo (espiral)
El modelo en espiral que Boehm propuso es un modelo de proceso de software evolutivo que conjuga la naturaleza iterativa de la construcción de prototipos con los aspectos controlados y sistemáticos del modelo en cascada. Cuando se aplica este modelo en espiral, el software se desarrolla en una serie de entregas evolutivas. Cada una de las actividades del marco de trabajo representan un segmento de la ruta en espiral. 

Este modelo se basa en la idea de desarrollar una implementación inicial, exponiéndola a los comentarios del usuario y refinándola a través de las diferentes versiones que se generan hasta que se desarrolle un sistema adecuado.

Las actividades de especificación, desarrollo y validación se entrelazan en vez de separarse, con una rápida retroalimentación entre estas. Existen dos tipos de desarrollo evolutivo:
1) Desarrollo exploratorio, en este caso el objetivo del proceso es trabajar con el cliente para explorar sus requerimientos y entregar un sistema final. El desarrollo empieza con las partes del sistema que se comprenden mejor. El sistema evoluciona agregando nuevos atributos propuestos por el cliente. 

2) Prototipos desechables, el objetivo de este proceso de desarrollo evolutivo es comprender los requerimientos del cliente para así desarrollar una definición mejorada de los requerimientos para el sistema. El prototipo se centra en experimentar los requerimientos del cliente que no se comprenden del todo.

Haciendo referencia a la producción del software, un enfoque evolutivo suele ser más efectivo que el enfoque en cascada, ya que satisface las necesidades inmediatas de los clientes. La ventaja de un software que se basa en un enfoque evolutivo es que las especificaciones se pueden desarrollar de forma creciente. Tan pronto como los usuarios desarrollen un mejor entendimiento de su problema, esto se puede reflejar en el software. Sin embargo, desde la perspectiva de ingeniería y de gestión, el enfoque evolutivo tiene dos problemas:
1) El proceso no es visible. Esto significa que los administradores tienen que hacer entregas regulares para medir el progreso del producto. Si los sistemas se desarrollan rápidamente, no es rentable producir documentos que reflejen cada versión del sistema. 

2) A menudo los sistemas tienen una estructura deficiente. Esto hace referencia que los cambios continuos tienden a corromper la estructura del software. Incorporar cambios en él se convierte cada vez más en una tarea difícil y costosa.

Para sistemas pequeños y de tamaño medio (hasta 500,000 líneas de código), el enfoque evolutivo de desarrollo es el mejor. Los problemas del desarrollo evolutivo se hacen particularmente agudos para sistemas grandes y complejos con un período de vida largo, donde diferentes equipos desarrollan distintas partes del sistema. Es difícil establecer una arquitectura del sistema usando este enfoque, ya que hace difícil integrar las contribuciones de los equipos. Para sistemas grandes se recomienda un proceso mixto es decir que incorpore las mejores características del modelo en cascada y del desarrollo evolutivo. Esto implica desarrollar un prototipo desechable, utilizando un enfoque evolutivo para resolver incertidumbres en la especificación del sistema. Puede entonces no implementarse utilizando un enfoque más estructurado.

C.	El modelo de desarrollo basado en componentes
En la mayoría de los proyectos de desarrollo de software existe la reutilización. Por lo general esto sucede informalmente cuando las personas conocen diseños o códigos similares al requerido. Los buscan, los modifican según lo creen necesario y los incorporan en un nuevo sistema. El enfoque evolutivo, la reutilización es indispensable para el desarrollo más ágil de un sistema. Esta reutilización es independiente del proceso de desarrollo que se utilice. Sin embargo, en los últimos años ha surgido un enfoque de desarrollo de software denominado " ingeniería de software basada en componentes", el cual se basa en la reutilización. Este enfoque se basa en la reutilización y se compone de una gran base de componentes de software que son reutilizables.

Aunque la etapa de especificación de requerimientos y la revalidación son comparables con otros procesos, las etapas intermedias en el proceso orientado a la reutilización son diferentes. Estas etapas son:
1) Análisis de componentes. En esta se buscan los componentes para implementar los con base en su especificación. Por lo general, no existe una concordancia exacta y los componentes que se utilizan sólo proporcionan parte de la funcionalidad requerida. 

2) Modificación de requerimientos. En esta etapa los requerimientos se analizan utilizando información acerca de los componentes que se han descubierto. Entonces dichos componentes se modifican para reflejar los componentes disponibles, la actividad de análisis de componentes se puede llevar a cabo para buscar soluciones alternativas. 

3) Diseño del sistema con reutilización. En esta fase los diseñadores tienen en cuenta los componentes que se reutiliza y que se organizan el marco de trabajo para que los satisfaga. Si dichos componentes no están disponibles se puede diseñar nuevos software. 

4) Desarrollo e integración. El software que no se puede adquirir externamente se desarrolla y se integra a los componentes. En este modelo, la integración del sistema es parte del proceso de desarrollo, más que una actividad separada.

El modelo de desarrollo de software basado en componentes creado por Boehm (1988), tiene la ventaja de reducir la cantidad de software que se debe desarrollar y por ende reduce los costos y los riesgos. También permite una entrega más rápida del software. Sin embargo, los compromisos a los requerimientos son inevitables y esto da lugar a un sistema que no cumpla con las necesidades reales de los usuarios. Pressman (2006), detecto que:
“El software de computadoras moderno se caracteriza por el cambio continuo, los tiempos de entrega son muy reducidos y una necesidad intensa de satisfacer al cliente/usuario. En muchos casos, el tiempo de llegada al mercado es el requisito de gestión más importante. Si se pierde una ventana del mercado, el mismo proyecto de software puede perder su significado”.

2.11.3 Metodologías.

Las metodologías han evolucionado de manera significativa en las últimas décadas como se puede observar en la tabla 2.7 Permitiendo así el éxito o el fracaso de muchos de los sistemas desarrollados para distintas áreas. 

Algunas de las metodologías tradicionales más utilizadas para el desarrollo de software han sido, la denominada “proceso personal de software (PSP)” y la “proceso en equipo para el software TSP”. El TSP toma sus fundamentos en que los ingenieros deben de dar a conocer bien su trabajo y que puedan implementar un plan para poderlo realizar mejor, cuando el plan se implementa, pueden ahorrarse tiempo en realizar el trabajo y por ende generar productos de calidad. El TSP contempla dos componentes principales: 
1)	Creación de equipo
2)	Trabajo en equipo o componente de gestión.

El TSP es una metodología para dirigir el desarrollo de software además de establecer un entorno donde el trabajo efectivo de equipo sea normal y natural. En donde involucra a los ingenieros a desarrollar un trabajo en equipo. El desarrollo del (TSP) toma sus bases en la estrategia de calidad que propuso W. Edwards Deming (1982), con las etapas de planear, hacer, verificar y actuar. Y J.M. Juran (1988). El TSP ofrece un contexto disciplinado para el trabajo de la ingeniería del software. La motivación principal es que los ingenieros siguiendo esta metodología pueden hacer un excelente trabajo. Los ingenieros deben estar bien capacitados, bien entrenados y deben ser bien dirigidos por un miembro calificado que entienda bien la metodología del TSP. El objetivo principal del TSP es guiar debidamente a sus equipos de ingenieros. El TSP proporciona un proceso operacional definido para guiar a los ingenieros y administradores a través de diferentes pasos para la formación de equipos de trabajo.

Antes de que los miembros del equipo de trabajo participen en el equipo de TSP, deben saber cómo organizar bien su trabajo. Se requiere que el equipo o el personal se encuentre entrenado primero con el Personal Software Process (PSP). Esto le permite a los ingenieros obtener el conocimiento en saber cómo crear un plan detallado, reuniendo y usando procesos de datos, usando valores obtenidos para seguir un proyecto en donde puedan medir y dirigir la calidad del producto. El objetivo del PSP es poner a los profesionales de software a cargo de su trabajo y para que se sientan personalmente responsables de la calidad de los productos que producen. PSP puede trabajar a la par con los objetivos de la metodología (TSP) son:
1) Proporcionar un entorno de equipo que apoya el trabajo de la PSP 
2) Construir y mantener un equipo autodirigido.

PSP y TSP son potentes herramientas que proporcionan los conocimientos necesarios, la disciplina y el compromiso necesarios para los proyectos de software exitoso. Se sabe que en nuestro país para que se pueda producir software con calidad se debe de adoptar un nivel de madurez de procesos alto, es decir, que sea equiparable a los niveles internacionales, esto es a través del CMMI (Capability Maturity Model Integration), pero es difícil implementarlo en organizaciones pequeñas. En México se cuenta con la norma mexicana basada en MoProsoft (Modelo de Procesos para la Industria del Software), pero esta se centra en los procesos de las organizaciones pero no en las personas, que son los más importantes para que ellas funcionen. En México no solamente se debe incrementar el nivel de madurez en los procesos de la industria de Software, si no que, se debe incluir el mejoramiento del elemento básico que sustente la industria, que son las personas.

Con PSP, los desarrolladores utilizan procesos bien definidos y medibles. Se toma información de tamaño, tiempo y defectos al momento de realizar el trabajo. Se utilizan los datos para: planear y monitorear el trabajo, así como administrar la calidad de los productos que se producen y medir el desempeño. TSP ha permitido resolver problemas típicos de negocio: como predecir el costo y tiempo, mejorar la productividad y establecer ciclos de desarrollo para generar la mejora en la calidad de los productos. PSP/TSP mejoran el desempeño tanto de equipos como de individuos; es disciplinado y dirigida en todo su desarrollo a la planeación; provee beneficios inmediatos y medibles; acelera las iniciativas de mejora de los procesos organizacionales. Con TSP, los equipos encuentran y reparan defectos en etapas tempranas del proceso de desarrollo. Esto reduce de manera importante el tiempo de pruebas.

2.11.3.1 Metodologías para el desarrollo ágil del software.
Actualmente los negocios operan en un entorno global que cambia rápidamente. Tienen que responder a nuevas oportunidades y mercados, condiciones económicas cambiantes y la aparición de productos y servicios competidores. El software es parte de casi todas las operaciones de negocio, por lo que es fundamental que el software nuevo se desarrolle rápidamente para aprovechar nuevas oportunidades y responder a la presión competitiva. Actualmente el desarrollo y entrega de manera rápida son los requerimientos más críticos de los sistemas. De hecho, muchas organizaciones están dispuestas a obtener una pérdida en la calidad del software y en el compromiso sobre los requerimientos en favor de una entrega rápida del software.

Los procesos de desarrollo del software basados en una completa especificación de los requerimientos, diseño, construcción y pruebas del sistema no se ajustan al desarrollo rápido de aplicaciones. Cuando los requerimientos cambian o se descubren problemas con ellos, el diseño o implementación del sistema se tiene que volver a realizar o probar. Como consecuencia, normalmente se prolonga en el tiempo un proceso en cascada convencional y el software definitivo se entrega mucho tiempo después al cliente con el que inicialmente se pactó. En un entorno de negocios tan cambiante, esto puede causar verdaderos problemas. Para cuando esté disponible el software, la razón original de su adquisición puede ser que haya cambiado de forma radical que en realidad éste sea inútil. Dicha metodología combina una filosofía y un conjunto de directrices de desarrollo. La filosofía busca la satisfacción del cliente y la entrega temprana de software incremental, equipos pequeños con alta motivación, métodos informales y una simplicidad general del desarrollo. Los procesos de desarrollo rápido de software están diseñados para producir software útil de forma rápida. Generalmente, son procesos interactivos en los que se entrelazan la especificación, el diseño, el desarrollo y las pruebas.

En los años 80 y principios de los 90, existía una opinión general de que la mejor forma de obtener un software de calidad era a través de una planificación cuidadosa del proyecto y de la utilización de métodos de análisis y diseño soportados por herramientas CASE (Computer Aided Software Engineering). Esta opinión venía fundamentalmente de la comunidad de ingenieros de software implicado en el desarrollo de grandes sistemas y que normalmente se componían de un gran número de programas individuales. Este software era desarrollado por grandes equipos que trabajaban para compañías diferentes y que a menudo estaban dispersos geográficamente y trabajaban durante largos periodos de tiempo.

Sin embargo, cuando este enfoque era aplicado a sistemas de negocios pequeños y de tamaño medio, el esfuerzo invertido era tan grande que algunas veces dominaba el proceso de desarrollo del software, es decir, se pasaba más tiempo pensando en cómo se debía desarrollar el sistema que en cómo programar el desarrollo y cómo hacer las pruebas pertinentes. El descontento de esto produjo que varios desarrolladores propusieran nuevos métodos que eran más ágiles. Aunque estos métodos se basan principalmente en la noción del desarrollo y en las entregas incrementales, proponen procesos diferentes para alcanzar el objetivo.

En una reunión celebrada en febrero de 2001 en Utah-EEUU, nace el término "ágil" aplicado al desarrollo de software. En esta reunión participan un grupo de diecisiete expertos de la industria del software, incluyendo algunos de los creadores o impulsores de metodologías de software. Su objetivo fue esbozar los valores y principios que deberían permitir a los equipos a desarrollar software rápidamente y respondiendo a los cambios que podrían surgir a lo largo de los proyectos. Se pretendía ofrecer una alternativa a los procesos de desarrollo de software tradicionales, caracterizados por ser rígidos y dirigidos por la documentación que se genera en cada una de las actividades desarrolladas. Varias de las denominadas metodologías ágiles ya estaban siendo utilizadas con éxito en proyectos reales, pero les faltaba una mayor difusión y reconocimiento. Tras esta reunión se creó “The Agile Alliance” (2001), una organización, sin ánimo de lucro, dedicada a promover los conceptos relacionados con el desarrollo ágil de software y ayudar a las organizaciones para que adopten dichos conceptos.

El punto de partida fue el manifiesto ágil, un documento que resume la filosofía "ágil". A continuación en la tabla 2.8, vamos a enumerar las principales diferencias de una Metodología Ágil respecto a las Metodologías Tradicionales (llamadas peyorativamente “no ágiles” o “pesadas”). Estas diferencias que no se refieren sólo al proceso en sí, sino también al contexto de equipo y organización que es más favorable a cada uno de estas filosofías de procesos de desarrollo de software. 

Si bien la idea de participación del cliente en el proceso de desarrollo es atractiva, el éxito dependerá de tener un cliente que esté dispuesto y lo más importante pueda pasar tiempo con el equipo de desarrollo para así presentar a todos los implicados del sistema, los clientes están sometidos a otras presiones y no pueden participar plenamente en el desarrollo del software. El cliente es el punto clave, solicita los requerimientos que se deben de incluir. Los miembros individuales del equipo puede no tener la personalidad propia para una participación intensa. Por lo tanto, es posible que no se relacionen adecuadamente con los otros miembros del equipo. Priorizar los cambios puede ser extremadamente difícil, específicamente en sistemas en los que existen muchos implicados.

Mantener la simplicidad requiere un trabajo extra. Cuando se trabaja bajo presión por las agendas de entregas, los miembros del equipo no pueden tener a tiempo las especificaciones del sistema. Por consiguiente los métodos ágiles tienen que depender de contratos donde el cliente paga por el tiempo necesario para el desarrollo del sistema en lugar de por el desarrollo de un conjunto de requerimientos específicos. Siempre y cuando el proyecto vaya caminando en forma, esto beneficiará tanto al cliente como al desarrollador. Todos los métodos tienen límites y los métodos ágiles son apropiados para algunos tipos de desarrollo de sistemas. Son los más idóneos para el desarrollo de sistemas para pequeños negocios y medianas empresas. No son adecuados para el desarrollo de sistemas a gran escala con equipos de desarrollo situados en diferentes lugares geográficamente hablando ya que puede haber complejas interacciones con otros sistemas o hardware.

Los métodos ágiles no se deben de utilizar para el desarrollo de sistemas críticos en los que es necesario generar un análisis detallado de todos los requerimientos del sistema para así comprender mejor sus implicaciones de seguridad o de protección. El crecimiento de los métodos ágiles y su penetración ocurre a un ritmo pocas veces visto en la industria: en tres o cuatro años, según el Cutter Consortium, el 50% de las empresas define como “ágiles” más de la mitad de los métodos empleados en sus proyectos (Charette, 2004). Algunas de las metodologías agiles mas usadas en la actualidad se describen a continuación.

•	Metodología XP programación extrema
La programación extrema XP es posiblemente el método ágil más conocido y ampliamente utilizado. El nombre de XP fue acuñado por Beck (2000), debido a que el enfoque fue desarrollado utilizando las mejores prácticas del desarrollo iterativo y con la participación extrema del cliente. La programación extrema (XP), que algunos consideran una innovación extraordinaria y otros creen cínica (Rakitin, 2001). En la metodología extrema, todos los requerimientos se expresan como escenarios (llamados historias de usuario), los cuales se implementan directamente como una serie de tareas. Los programadores trabajan en parejas y desarrollan pruebas para cada tarea antes de escribir el código. Todas las pruebas se deben ejecutar satisfactoriamente cuando el código nuevo se integra al sistema. Existe un pequeño espacio de tiempo entre las entregas del sistema. 

El desarrollo incremental se lleva a través de entregas pequeñas y frecuentes del sistema y por medio de un enfoque que sirve para la descripción de requerimientos basado en las historias del clientes o escenarios que pueden ser la base para el proceso de planificación.

La participación del cliente se lleva a cabo a través del compromiso y del tiempo completo del cliente en el equipo de desarrollo. Los colaboradores directos de los clientes participan en el desarrollo y son los responsables de definir las pruebas necesarias que servirán para la aceptación del sistema. El interés de las personas, en vez de los procesos, se lleva a través de la programación en parejas, la propiedad colectiva del código y un proceso de desarrollo sostenible que no implique excesivas jornadas de trabajo. El cambio se lleva a cabo a través de las entregas regulares del sistema, un desarrollo previamente probado y la integración continua. El mantenimiento se lleva a cabo a través de una recta actualización constante para mejorar la calidad del código y la utilización de diseños sencillos que no prevén cambios futuros en el sistema.

En XP, los clientes están implicados en la especificación y establecimiento de prioridades de los requerimientos del sistema. Dichos requerimientos no se especifica como una lista de funciones requeridas en el sistema. Más bien, los clientes del sistema son parte fundamental del equipo de desarrollo esto permite que discutan escenarios con todos los miembros del equipo. Desarrollar conjuntamente tarjetas de historia (story card) que recogen las necesidades del cliente. Por ende el equipo de desarrollo intentará implementar esos escenarios en una entrega futura del software. Un punto fundamental en la ingeniería del soporte tradicional es que se debe de diseñar para futuros. Esto es que se deben de prever los cambios futuros y diseñar éste de forma que tales cambios se puedan implementar fácilmente. La metodología XP ha descartado este principio partiendo del hecho de que diseñar para el cambio es a menudo un esfuerzo inútil. Con frecuencia los cambios previstos nunca se materializa y realmente se efectúan peticiones de cambios completamente diferentes. La metodología extrema aborda este problema sugiriendo que se debe revisar constantemente el software. Esto es, que el equipo de programación busca posibles mejoras y las implementa de forma inmediata así lo que se busca es que siempre sea fácil de entender y cambiar cuando simplemente nuevas historias.

•	Metodología SCRUM
A pesar de que la metodología XP recibe la mayor atención bibliográfica, las organizaciones están enfocando su atención en la metodología ágil denominada SCRUM (Schwaber & Shuterland, 2011) (Shuterland, 2012), la cual aplica las mismas premisas conceptuales que XP pero para resolver un problema ligeramente distinto como es el de desarrollo evolutivo de aplicaciones. SCRUM es una metodología ágil y flexible que sirve para gestionar el desarrollo de software, cuyo principal objetivo es maximizar el retorno de la inversión para su empresa. Se basa principalmente en construir la funcionalidad de mayor valor para el cliente y en los principios de inspección continua, adaptación, auto-gestión e innovación. 

Con SCRUM el cliente es pieza fundamental en el desarrollo de software, se entusiasma y se compromete con el proyecto dado que lo ve crecer iteración a iteración. Asimismo le permite en cualquier momento realinear el software con los objetivos de negocio de su empresa, ya que puede introducir cambios funcionales o de prioridad en el inicio de cada nueva iteración. Esta forma de trabajo promueve la innovación, motivación y el compromiso del equipo que forma parte del proyecto, por lo que los profesionales encuentran un ámbito propicio para desarrollar sus capacidades. SCRUM genera algunas ventajas a diferencia de otras metodologías agiles entre ellas:
•	Cumplimento de expectativas: El cliente establece sus expectativas indicando el valor que aporta a cada requisito / historia del proyecto, el equipo los estima y con esta información el propietario del producto establece su prioridad. 

•	Flexibilidad a cambios: Genera una alta capacidad de reacción ante los cambios de requerimientos generados por necesidades del cliente o evoluciones del mercado. La metodología está diseñada para adaptarse a los cambios de requerimientos que conllevan los proyectos complejos. 

•	Reducción del tiempo: El cliente puede empezar a utilizar las funcionalidades más importantes del proyecto antes de que esté finalizado por completo. 

•	Mayor calidad del software: La forma de trabajo y la necesidad de obtener una versión funcional después de cada iteración, ayuda a la obtención de un software de calidad superior. 

•	Mayor productividad: Se consigue entre otras razones, gracias a la eliminación de la burocracia y a la motivación del equipo que proporciona el hecho de que sean autónomos para organizarse. 

•	Maximiza el retorno de la inversión (ROI): Producción de software únicamente con las prestaciones que aportan mayor valor de negocio gracias a la priorización por retorno de inversión. 

•	Predicciones de tiempos: Mediante esta metodología se conoce la velocidad media del equipo por sprint (los llamados puntos historia), con lo que consecuentemente, es posible estimar fácilmente para cuando se dispondrá de una determinada funcionalidad que todavía está retrasada. 

•	Reducción de riesgos: El hecho de llevar a cabo las funcionalidades de más valor en primer lugar y de conocer la velocidad con que el equipo avanza en el proyecto, permite despejar riesgos eficazmente de manera anticipada.

La totalidad de los requerimientos a desarrollar, denominados historias de usuario (“user stories”) son divididos en grupos en función de su prioridad relativa para luego ser implementados en ciclos de esfuerzos relativamente cortos llamados “sprints”; las tareas son organizadas en el equipo de tal manera que las asignaciones y prioridades se revisan diariamente en una reunión breve llamada “SCRUM” que le da su nombre la metodología. En este enfoque se siguen los principales criterios del manifiesto generando así liberaciones parciales incrementales del producto que se esta desarrollando. La evidencia es consistente que al abrazar la hoja de ruta y comprometer las inversiones necesarias para desplegar formalmente esta metodología también se abordan al mismo tiempo aspectos clave del despliegue de prácticas maduras de proceso.  
En tal sentido SCRUM ha sido exitosamente comparada contra los requisitos a satisfacer para alcanzar una de evaluación bajo niveles 2 y 3 del modelo CMMI (Shuterland, et al, 2008), (Turner & Jain, 2002). Demostrando así que la ejecución rigurosa satisface a la mayoría de los objetivos necesarios que sirven para obtener estos niveles; las pocas áreas del proceso no cubiertas directamente por no ser requeridos por SCRUM son en la práctica un requisito para el correcto desempeño de una organización dedicada a la construcción de software. 

•	Desarrollo adaptativo de software (DAS)
El desarrollo adaptativo software (DAS) lo propuso Jim Highsmith en 1998 como una técnica para construir software y sistemas complejos. Los apoyos filosóficos del DAS se enfocan en la colaboración humana y la organización propia del equipo. Un enfoque de desarrollo ágil y adaptativo basado en la colaboración es " una fuente de orden en las complejas interacciones entre disciplina e ingeniería". El define el ciclo de vida del DAS, como se muestra en la figura 2.29 el cual incorpora tres fases principales:
1)	Especulación; en esta fase se inicia el proyecto y se conduce el ciclo adaptativo de planeación. Este último utiliza información de inicio del proyecto, es decir, el enunciado de la misión del cliente, restricciones del proyecto y los requisitos básicos. Esto permite definir el conjunto de ciclos de lanzamiento que se requerirán para el proyecto. 

2)	Colaboración; la gente motivada trabaja de una forma que multiplica su talento y sus salidas creativas más allá de sus números absolutos. Este enfoque de colaboración es un tema recurrente en todos los métodos ágiles, pero la cooperación no es fácil. No solamente es la comunicación, o que la comunicación es parte de ella. No sólo es un asunto de trabajo en equipo, aunque un equipo cuajado es esencial para la presencia de la colaboración real. No es un rechazo al individualismo ya que la creatividad individual representa un papel importante en el pensamiento de colaboración. Esto es, por encima de todo, una cuestión de confianza. Las personas que trabajan juntas deben confiar entre sí para:
a) Criticar de forma constructiva
b) Ayudar sin resentimientos
c) Trabajar más duro de lo que ya lo hace
d) Tener el conjunto de actitudes para contribuir al trabajo curso
e) Comunicar los problemas o preocupaciones en una forma que conduzca a la acción efectiva
3) Aprendizaje; como miembros de un equipo de DAS se comienzan a desarrollar los componentes integrantes de un ciclo adaptativo, la importancia radica en el aprendizaje y en el progreso a través de un ciclo completo. De hecho Highsmith (2002), argumenta que los desarrolladores de software a menudo sobreestima su comprensión (de la tecnología, el proceso y el proyecto), y que el aprendizaje les podré ayudar a mejorar su grado de entendimiento real. Los equipos del DAS aprenden de tres maneras:
a)	Grupos enfocados. El cliente o los usuarios finales proporcionan retroalimentación sobre los incrementos de software que se entregan. Esto indica en forma directa la satisfacción o la insatisfacción de las necesidades del negocio. 

b)	Revisiones técnicas formales. Los miembros del equipo del DAS revisan los componentes del software desarrollado mientras mejoran su calidad y su aprendizaje. 

c)	Post mortem. El equipo de DAS se vuelve introspectivo al vigilar su propio desempeño y proceso con el propósito de aprender acerca de su enfoque y después mejorarlo. 

Es importante destacar que la filosofía del DAS es meritoria sin importar el modelo del proceso empleado. La dinámica de la organización propia los equipos, la colaboración interpersonal y el aprendizaje individual conducen a los grupos de proyectos de software con una mayor posibilidad de éxito
=======
Ingeniería de Requisitos
Ingeniería de Requisitos, es el proceso de desarrollar una especificación de Software. Las especificaciones pretenden comunicar las necesidades del sistema del cliente a los desarrolladores del sistema. Trata de los principios, métodos, técnicas y herramientas que permiten descubrir, documentar y mantener los requisitos para sistemas basados en computadora, de forma sistemática y repetible.
Importancia
Los principales beneficios que se obtienen de la Ingeniería de Requisitos son:

Permite gestionar las necesidades del proyecto en forma estructurada: Cada actividad de la Ingeniería de Requisitos consiste de una serie de pasos organizados y bien definidos.
Mejora la capacidad de predecir cronogramas de proyectos, así como sus resultados: La Ingeniería de Requisitos proporciona un punto de partida para controles subsecuentes y actividades de mantenimiento, tales como estimación de costos, tiempo y recursos necesarios.
Disminuye los costos y retrasos del proyecto: Muchos estudios han demostrado que reparar errores por un mal desarrollo no descubierto a tiempo, es sumamente caro; especialmente aquellas decisiones tomadas durante la Especificación de Requisitos.
Mejora la calidad del software: La calidad en el software tiene que ver con cumplir un conjunto de requisitos (Funcionalidad, Facilidad de Uso, Confiabilidad Desempeño, etc.).
Mejora la comunicación entre equipos: La especificación de requisitos representa una forma de consenso entre clientes y desarrolladores. Si este consenso no ocurre, el proyecto no será exitoso.
Evita rechazos de usuarios finales: La Ingeniería de Requisitos obliga al cliente a considerar sus requisitos cuidadosamente y revisarlos dentro del marco del problema, por lo que se le involucra durante todo el desarrollo del proyecto.
Actividades
Existen cuatro actividades básicas (extracción, análisis, especificación y validación) que se tienen que llevar a cabo para completar el proceso. Estas actividades ayudan a reconocer la importancia que tiene, para el desarrollo de un proyecto de software, realizar una especificación y administración adecuada de los requisitos de los clientes o usuarios.

Extracción: Esta fase representa el comienzo de cada ciclo. Extracción es el nombre comúnmente dado a las actividades involucradas en el descubrimiento de los requisitos del sistema.
Análisis: Sobre la base de la extracción realizada previamente, comienza esta fase. Usualmente se hace un análisis luego de haber producido un bosquejo inicial del documento de requisitos; aquí se leen los requisitos, se conceptúan, se investigan, se intercambian ideas con el resto del equipo, se resaltan los problemas, se buscan alternativas y soluciones, y luego se van fijando reuniones con el cliente para discutir los requisitos.
Especificación: En esta fase se documentan los requisitos acordados con el cliente, en un nivel apropiado de detalle. En la práctica, esta etapa se va realizando conjuntamente con el análisis, pero se podría decir que la Especificación es el “pasar en limpio” el análisis realizado previamente aplicando técnicas y/o estándares de documentación, como la notación UML.
Validación: La validación es la etapa final de la IR. Su objetivo es verificar todos los requisitos que aparecen en el documento especificado para asegurarse que representan una descripción, por lo menos, aceptable del sistema que se debe implementar. Esto implica verificar que los requisitos sean consistentes y que estén completos.
La validación representa un punto de control interno y externo; interno, porque se debe verificar internamente lo que se está haciendo, y externo, porque se debe validar con el cliente.
Herramientas
Existen diversas técnicas y herramientas que se utilizan para llevar a cabo cada una de las actividades del proceso de Ingeniería de Requisitos, una de las razones por las cuales surgen los errores a la hora del levantamiento es la existencia de una gama de herramientas. No existe una especie de guía para el uso de los desarrolladores, estos utilizan incluso en la captura más de una técnica en cada de las actividades que contiene el proceso.
Herramientas más Usadas

Entrevistas y cuestionarios: Las entrevistas y cuestionarios se emplean para reunir información proveniente de personas o grupos, información que se obtiene conversando con el encuestado. Las preguntas suelen distinguirse en dos categorías: abiertas y cerradas. Las preguntas abiertas permiten que los encuestados respondan con su propia terminología, mientras que las preguntas cerradas predeterminan todas las posibles respuestas y el interrogado elige entre las opciones presentadas.
Grabaciones de video y de audio: Básicamente existen dos formas de utilizar las grabaciones: como registro y apoyo de las entrevistas, y para analizar algún proceso en particular. En cuanto a su función de apoyo, es importante porque permite centrar la atención en la entrevista en sí, en vez de distraerse tomando notas de todo lo que se dice. Cuando se trata de analizar algún proceso en particular, su ayuda es inestimable (sobre todo las filmaciones de video) porque permite ver y analizar en detalle ese proceso la cantidad de veces que sea necesario.
Brainstorming (tormenta de ideas): Este es un modelo que se usa para generar ideas. La intención en su aplicación es la de generar la máxima cantidad posible de requisitos para el sistema. No hay que detenerse en pensar si la idea es o no del todo utilizable.
>>>>>>> origin/isidro
